-- 型クラス

{-
型クラスとは、何らかの振る舞いを定義するインターフェイス。らしい。
↑よくわからないけど、== とかは比べることを可能にしている
これは Eq という型クラスによって定義されているからである


なので、== を使う際にはその２引数は両方Eqクラスのインスタンスでなければならない
この(Eq a) => の部分はそのことを表している！！

:t (==)
(==) :: (Eq a) => a -> a -> Bool

この => というシンボルよりも前にあるもの(Eq a)のことを
               型クラス制約           と呼ぶ


型クラスはオブジェクト指向のクラスとは同じではない
-}

{-
Eq 型クラス
等植性をテストできる型に使われる。Eqのインスタンスが実装すべき関数は
== と /= である
型が関数を実装しているとは、その関数がその特定の型に対して使われたとき、どういう振る舞いをするか定義するということ
（例）リスト
    最初の要素から順に見ていって、一つでも違えばFalseを返す
    # リストは型じゃないから違うかも でもこんな感じだと思う


Ord 型クラス
何らかの順序を付けられる型のためのクラス
>、<、>=、<= をサポートしている

compare 関数は Ord のインスタンスの型の引数を２つ取り、Orderingを返す
GT、LT、EQ のいずれかの値を取る型
compare "Asassin" "Zelda"  ->  LT
5 `compare` 3  ->  GT


Show 型クラス
値を文字列として表現するための型クラス。このインスタンスであれば表示ができる
show 3  ->  "3"
show 3.14  ->  "3.14"
show True  ->  "True"


Read 型クラス
Show と対をなす型クラス. 文字列を受け取りReadのインスタンスの型の値を返す
read "13" - 2  ->  11

Read では型を推論して返すので、結果の値に何かしらの手を加える必要がある
以下はそのエラーたち
  read "4"
Readクラスのどれかを返すことしかわからず、具体的に何を返せば良いのかわからない
  compare (read "7") "2"

これを解決するために！！型注釈という、式が取るべき型を明示的に教えてあげる手段がある

read "5" :: Int  ->  5
read "5" :: Float  ->  5.0
read "[4, 9, 6]" :: [Int]  ->  [4, 9, 6]
read "(3, 'a')" :: (Int, Char)  ->  (3, 'a')

Haskellは静的型付け言語なので、コンパイルする前にすべての型がわかっている必要がある。

-}
-- 今まで見てきたすべての型はこれらの型クラスのインスタンスである
