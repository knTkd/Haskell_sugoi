{-# OPTIONS -Wall -Werror #-}

-- 畳み込み、見込みアリ！

sum' :: (Num a) => [a] -> a
sum' xs = foldl (\acc x -> acc + x) 0 xs

{-
畳み込みを使った sum 関数
畳み込みは
  2引数関数 アキュムレータの初期値 リスト
の3つを引数としてもらう

上で言うと、
(\acc x -> acc + x) が2引数関数
        0           がアキュムレータの初期値
        xs          がリスト
となっている

畳み込み関数は2引数関数（2つの引数を取る関数。+やdivなど）と、畳み込みに用いる値（アキュムレータと呼ばれることが多い）の初期値、それに畳み込むリストを受け取る

畳み込み関数はアキュムレータとリストの先頭（あるいは最後）の要素を引数として、与えられた2引数関数を呼び出す
その結果の値が新しいアキュムレータになる...というのをリスト全体を操作しきって単一のアキュムレータの値になるまで繰り返す

上で作ったsum'に[3,5,2]を与えたときの動きを具体的に見る

0 [3,5,2] で2引数関数が呼び出される アキュムレータ = 0 + 3 = 3
3 [5,2] で畳み込まれ、 アキュムレータ = 3 + 5 = 8
8 [2]        アキュムレータ = 8 + 2 = 10
単一の値になったので終了

下は関数がカリー化されていることを利用してより簡潔に実装したものである
-}
sum'' :: (Num a) => [a] -> a
sum'' = foldl (+) 0
{-
ラムダ式(\acc x -> acc + x)は(+)と同じ
foldl (+) 0 はリストを取る関数を返すので、引数のxsは省略できる

一般に、foo a = bar b a のような関数があった場合、カリー化のおかげで foo = bar b のように書き換えれる
-}

-- foldr
{-
foldrはリストを右から順に処理する（ように見えているだけで、実際には左から走査している）

下のmap'はアキュムレータの初期値が[]でそれの先頭に関数から帰った値をconsしていってる
-}
map' :: (a -> b) -> [a] -> [b]
map' f = foldr (\x acc -> f x : acc) [] 
{-
左畳み込みを使えば下のようにも実装できる
ただ、++関数は:よりも遥かに遅いので、リストから新しいリストを構築する際には、普通は右畳み込みを使う
map' :: (a -> b) -> [a] -> [b]
map' f xs = foldl (\acc x -> acc ++ [f x]) [] xs
-}

-- elem の foldl での実装
elem' :: (Eq a) => a -> [a] -> Bool
elem' a xs = foldl (\acc x -> if a == x then True else acc) False xs


-- 右畳み込みと左畳み込みのもう一つの大きな違いは無限リストに対して動作するのは右だけ！！


{- foldl1 と foldr1関数

これらは似てるけど、初期アキュムレータを明示的に与える必要が無い
リストの先頭（あるいは末尾）の要素を初期アキュムレータとして使う

例えば、maximum 関数は以下のようになる
リストの最初の要素を初期アキュムレータとみなし、二番目の要素から畳み込まれていく
-}
maximum' :: Ord a => [a] -> a
maximum' = foldl1 max

-- foldl1 や foldr1 は空のリストに対して呼び出すとランタイムエラーが発生する
