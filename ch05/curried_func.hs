{-# OPTIONS -Wall -Werror #-}

-- カリー化関数

{-
Haskell のすべての関数は公式には引数を”ひとつ”だけ取ることになっている

複数の引数を受け取れるかのように見えた関数はすべてカリー化された関数だった！
カリー化関数は常にちょうど１つの引数を取る関数
呼び出されると、その次の引数を受け取る関数を返す


関数を本来より少ない引数で呼び出すと、部分適用された関数が得られる
（例） compareWithFive = compare 5  -- 5と比べる関数
部分適用された関数は残りの変数を引数として取る関数
-}

-- 3 だけ足す関数を考えてみる
-- まずは普通の足し算をする関数
plus' :: (Num a) => a -> a -> a
plus' a b = a + b

-- この関数は(引数を取らず)、(Numの引数を１つ取りNumを返す関数)を、返す
-- (Num a) => a -> a のようにもかけるが、(a -> a)は返される関数の情報なのでこっちのほうが見やすい気がする
plus3 :: (Num a) => (a -> a)
plus3 = plus' 3



multThree :: Int -> Int -> Int -> Int
multThree a b c = a * b * c
{-
multThree 3 5 9 もしくは (((multThree 3) 5) 9)を呼び出したときのプロセス

(i)まず、multThree が 3 に適用される これにより「引数を1つ取って関数を返す関数」がかえる
(ii)次に、その帰ってきた関数が 5 に適用される これにより「引数を1つ取ってそれに3と5を掛けた数を返す関数」が帰る
(iii)そして、その関数が 9 に適用され、135が最終的な結果となる


関数は何か材料を受け取って何かを作り出す小さな工場だと考えることができる
この比喩を使うと、「multThree に数 3 を与えたら、数ではなくて、ちょっと小さくなった別の工場が出てきた」と言える

型は次のようにも書ける
multThree :: Int -> (Int -> (Int -> Int))
-}

