{-# OPTIONS -Wall -Werror #-}

-- 関数合成

{-
数学における関数合成は (f❍ g)(x) = f(g(x)) のように定義される
Haskell の関数合成もこれとほとんど同じで、「.」関数を使って関数合成ができる
定義
(.) :: (b -> c) -> (a -> b) -> a -> c
f . g = \x -> f (g x)

型宣言に注意  f の引数は g の返り値と同じ型を受け取る必要がある


関数合成の用途としては他の関数に渡す関数をその場で作るというものがある
これはラムダ式でもできるが、大抵は関数合成のほうが明快で簡潔

例えば、数のリストがあって、その全部を負の数にしたいとする(negate 関数は符号反転の関数)

ラムダ式バージョン
ghci> map (\x -> negate (abs x)) [5,-3,-6,7,2]
[-5,-3,-6,-7,-2]

関数合成バージョン
ghci> map (negate . abs) [5,-3,-6,7,2]
[-5,-3,-6,-7,-2]

明快で簡潔！！！

関数合成は右結合なので、一度にたくさんの関数を合成できる
f (g (z x)) は (f . g . z) x と等価


使用例
sum (replicate 4 (max 6.7 8.9))
を
sum . replicate 4 $ max 6.7 8.9

replicate 2 (product (map (*3) (zipWith max [1,2] [4,5])))
を
replicate 2 . product . map (*3) $ zipWith max [1,2] [4,5]
-}



-- ポイントフリースタイル  （関数合成のもう一つの一般的な使い道）

{-
ポイントとは、 fn x = f (g x) のような関数定義に登場する一時変数 x のこと
ポイントを使わないで定義するスタイルなので、ポイントフリースタイルという

例えば、
sum' :: (Num a) => [a] -> a
sum' xs = foldl (+) 0 xs
という関数を書いた時、関数はカリー化されているので、この両側のxsは省略できる
これをポイントフリースタイルで書くと、
sum ' = foldl (+) 0
となる


ここで次の関数をポイントフリースタイルで書きたい時、関数合成が役に立つ
fn x = ceiling (negate (tan (cos (max 50 x))))

これは両方に x があるが、括弧で囲まれているので取り除けない
ここで関数合成で表現すると、

fn = ceiling . negate . tan . cos . max 50

となる！！！！！！！！明快で簡潔
読みやすさだけじゃなく、データよりも関数に目が行くようになり、どのようにデータが移り変わっていくかではなくどんな関数を合成して何になっているかを考えやすくなる
単純な関数からはじめ、関数合成を糊として使うことで、より複雑な関数を作れば良い

とはいえ関数合成のチェインはあまり長くしすぎず、let を使って途中の結果にラベルを与え、問題を小さな問題に分解すれば、読む人にとってわかりやすいコードとなる
-}

-- この章の前半で解いた、奇数の平方数で10000より小さいものの総和を求める問題を関数にしてみる

oddSquareSum :: Integer
--oddSquareSum = sum (takeWhile (<10000) (filter odd (map (^(2 :: Int)) [1..])))
oddSquareSum = sum . takeWhile (<10000) . filter odd $ map (^(2 :: Int)) [1..]

-- と書き換えることができる(二行目が今まで、三行目が関数合成)


-- 課題  ~~  . と $ のが使い分けがニュアンスでしかできない
