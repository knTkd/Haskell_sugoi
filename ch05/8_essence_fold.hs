{-# OPTIONS -Wall -Werror #-}

-- 畳み込みの本質

{-
右と左の畳み込みは、リストの要素に対する一連の関数適用と見ることもできる
2引数 f と初期アキュムレータ z による右畳み込みがあるとすると、
リスト[3,4,5,6]に対して、本質的には次のようなことを行う

f 3 (f 4 (f 5 (f 6 z)))

+を前置関数として書くと

(+) 3 ((+) 4 ((+) 5 ((+) 6 z)))


左畳み込みの場合、2引数関数を g アキュムレータを z とすると、

g (g (g (g z 3) 4) 5) 6

となる。ここに左畳み込みが無限リスト受け付けないことの本質がある

右畳込みでは、第1引数をまずもらっている。
無限リストでは遅延評価で本当に必要な部分だけを計算する
例えば、Boolのリストをもらって全部の&&を計算する and関数がある
これは要素にFalseが出た時点で評価を終了する
右畳み込みでは最初から引数が入っていくので、Falseが入った時点で評価が終了する
一方、左畳込みでは一度でも引数が入るのは底まで行ってからである。（上のg (g (g (...を見たとおり）

ghci> foldr (&&) True (repeat False)
では (&&) False ((&&) False ((&&) False ....と無限に続くが、最初のFalseが入った時点で評価はFalseになり終了する


しかし、
ghci> foldl (&&) True (repeat False)
では (&&) ((&&) ((&&) ....と底に行くまで最初の値は入らない。これは実際に実行してもいつまでも終わらない


アキュムレータの初期値としてFalseを与えすらしてもできない
ghci> foldl (&&) False (repeat False)
....

無限リストを扱うときには foldr のみ、というのは以上が理由
逆にfoldrで無限リストを扱えるのはHaskellが遅延評価だから


上の理由で、foldl rの中のラムダ式は
foldl の場合 (\acc x -> )
foldr の場合 (\x acc -> )
となってる
-}
